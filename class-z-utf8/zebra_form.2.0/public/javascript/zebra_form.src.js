var Zebra_Form = new Class({

    Implements: [Options, Events],

    validation_rules: new Object,
    controls_groups: new Object,
    placeholders: new Object,
    error_blocks: new Object,
    form: null,
    reload: false,

    options: {
        scroll_to_error: true,
        tips_position: 'left',
        close_tips: true,
        process_path: null

        // onValid
    },

    // code by Joyce Babu
    // found at http://www.weberdev.com/get_example-4437.html

    filter_input: function(filter_type, evt, custom_chars)
    {
        var key_code, key, control, filter = '';
        var alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var digits = '0123456789';
        if (window.event) {
            key_code = window.event.keyCode;
            evt = window.event;
        } else if (evt)
            key_code = evt.which;
        else
            return true;
        switch (filter_type) {
            case 'alphabet':
                filter = alphabet;
                break;
            case 'digits':
            case 'number':
            case 'float':
                filter = digits;
                break;
            case 'alphanumeric':
                filter = alphabet + digits;
                break;
            default:
                return true;
        }
        if (custom_chars) { filter += custom_chars }
        control = evt.srcElement ? evt.srcElement : evt.target || evt.currentTarget;
        if (key_code==null || key_code==0 || key_code==8 || key_code==9 || key_code==13 || key_code==27) return true;
        key = String.fromCharCode(key_code);
        if (filter.indexOf(key) > -1) return true;
        if (filter_type == 'number' && key == '-' && control.getCaretPosition() == 0) return true;
        if (filter_type == 'float' && ((key == '-' && control.getCaretPosition() == 0) || (key == '.' && control.getCaretPosition() != 0 && control.value.match(/\./) == null))) return true;
        return false;
    },

    /**
     *  Shows or hides, as necessary, the "other" options for a "select" control, that has an "other" option set.
     *
     *  @param  DOM_element     element     A  <select> element having the "other" property set.
     *
     *  @return void
     */
    _show_hide_other_option: function(select) {

        // reference to the "other option" text box
        // it has the ID of the select control, suffixed by "_other"
        var element = $(select.get('id') + '_other');

        // if the select control's value is "other"
        if (select.value == 'other') {

            // show the "other option" text box
            element.setStyle('display', 'block');

        // if the select control's value is different than "other"
        } else {

            // hide the "other option" text box
            element.setStyle('display', 'none');

        }

    },

    /**
     *  Initializez the Zebra_Form object.
     *
     *  @param  string      form_id     The ID of a form generated by the Zebra_Form PHP class.
     *
     *  @param  object      options     Configuration options.
     *
     *  @return void
     */
    initialize: function(form_id, options) {

        // if form_id is an object rather than a string
        if('object' == typeof(form_id)) {

            // get the ID of the form
            this.form_id = form_id.get('id');

            // cache the form object
            this.form = form_id;

        // if an object with the given ID exists
        } else if ($(form_id)) {

            // save form's ID
            this.form_id = form_id;

            // cache the form object
            this.form = $(form_id);
        }

        // if everything is OK so far
        if (null != this.form) {

            // set the object's properties
            this.setOptions(options);

            // detect MooTools version
            this.mootools_version = (typeof $extend == 'function' ? '1.2' : '1.3+');

            // find all dummy options (read below) and iterate through them
            this.form.getElements('option.dummy').each(function(option) {

                // remove element from the DOM
                // we need them"dummy options" to create valid HTML/XHTML output because empty option groups are not
                // allowed; unfortunately, IE does not support neither the "disabled" attribute nor styling these
                // empty options so we need to remove them from the DOM
                option.destroy();

            });

            // find any error blocks generated by the server-side script and iterate through them
            $$('.Zebra_Form div.error').each(function(error_block) {

                // setup the "morph" effect on the error block
                error_block.set('morph', {

                    duration: 250,

                    onComplete: function() {

                        // remove from the DOM
                        error_block.destroy();

                    }

                });

                // get a reference to the "close" button on the error block
                var close_button = error_block.getElement('div.close a');

                // onclick, morph the error block's height and opacity to 0
                close_button.addEvent('click', function(e) {

                    e.stop();

                    error_block.morph({'height': 0, 'opacity': 0});

                });

            });

            // get all the form's elements
            var elements = this.form.getElements('.control');

            // iterate through the form's elements
            elements.each(function(element, index) {

                // get the ID and the type of the element
                var attributes = element.getProperties('id', 'type');

                // highlight the row that the element is in
                // get the element's parent element that has the "row" class set
                var parent = element.getParent('.row');

                // if there is such an element
                if (undefined != parent) {

                    // bind these events to the element
                    element.addEvents({

                        // when the element receives focus
                        // add the "highlight" class to the parent element
                        'focus': function() { parent.addClass('highlight') },

                        // when the element receives focus
                        // remove the "highlight" class from the parent element
                        'blur': function() { parent.removeClass('highlight') }

                    });

                }

                if (

                    // if element has the "inner-label" class set
                    // meaning that the element's label needs to be shown inside the element until the element has focus
                    element.hasClass('inner-label') && (

                        // the class is applied to an allowed element type
                        attributes['type'] == 'text' ||
                        attributes['type'] == 'password' ||
                        attributes['type'] == 'textarea'

                    )

                ) {

                    // if mootools version is 1.2.x
                    if (this.mootools_version == '1.2') {

                        // extend "attributes" with some new entries
                        $extend(attributes, element.getProperties('class', 'style', 'alt'));

                    // if mootools version is 1.3.x
                    } else {

                        // extend "attributes" with some new entries
                        Object.append(attributes, element.getProperties('class', 'style', 'alt'));
                    }

                    // we need to create a "dummy" text element that will replace the original element until the "dummy"
                    // element receives the focus; the "dummy" element will "clone" the original element's ID, class and
                    // style
                    var placeholder = new Element('input', {
                        type:       'text',
                        'id':       attributes['id'],
                        'class':    attributes['class'].replace(/validate\[.*\]/, '').replace(/inner\-label/, '').trim() + ' placeholder',
                        'style':    attributes['style'],
                        'value':    attributes['alt'],
                        styles: {
                            display:    'none'
                        }
                    });

                    // cache the placeholder element
                    this.placeholders[attributes['id']] = placeholder;

                    // when the placeholder receives focus
                    placeholder.addEvent('focus', function() {

                        // hide the error message if it is visible
                        this.hide_error(element.get('name').replace(/\[\]$/, ''));

                        // hide the placeholder
                        placeholder.setStyle('display', 'none');

                        // show the original element
                        element.setStyle('display', element.hasClass('inline') ? 'inline' : 'block');

                        // set focus to the original element
                        element.focus();

                    }.bind(this));

                    // when the element loses focus
                    element.addEvent('blur', function() {

                        // if no value was entered
                        if (element.value == '') {

                            // hide the original element
                            element.setStyle('display', 'none');

                            // show the corresponding placeholder
                            this.placeholders[element.get('id')].setStyle('display', element.hasClass('inline') ? 'inline' : 'block');

                        }

                    // change the scope of "this" so that we can have access to the Zebra_Form object's properties and methods
                    }.bind(this));

                    // by default, if element has no value
                    if (element.value == '') {

                        // show the placeholder
                        placeholder.setStyle('display', element.hasClass('inline') ? 'inline' : 'block');

                        // and hide the original element
                        element.setStyle('display', 'none');

                    // if element has a default value, show the original element
                    } else element.setStyle('display', element.hasClass('inline') ? 'inline' : 'block');

                    // inject the placeholder into the DOM, right after the original element
                    placeholder.inject(element, 'after');

                // if element has the "other" class set and element is a drop-down
                } else if (element.hasClass('other') && attributes['type'] == 'select-one') {

                    // run this private method that shows/hides the "other" text box depending on the selection
                    this._show_hide_other_option(element);

                    // whenever the drop-down's value is changed
                    element.addEvent('change', function() {

                        // run this private method that shows/hides the "other" text box depending on the selection
                        this._show_hide_other_option(element);

                    // change the scope of "this" so that we can have access to the Zebra_Form object's properties and methods
                    }.bind(this));

                }

                // if there are any validation rules set for this element
                if (undefined != this.options.error_messages && undefined != typeof this.options.error_messages[attributes['id']]) {

                    // register the element
                    this.register(element, false);

                }

            // change the scope of "this" so that we can have access to the Zebra_Form object's properties and methods
            }.bind(this));

            // attach a function to the form's "submit" event
            this.form.addEvent('submit', function(e) {

                // if
                if (

                    // form is not to be simply reloaded
                    this.reload == false &&

                    // and there are any controls that need to be validated
                    undefined != this.options.error_messages

                ) {

                    // if not all controls validate
                    if (!this.validate()) {

                        // prevent the form from being submitted
                        // we check for the existence of "e" because the form can also be submitted by calling the
                        // submit() method, case in which "e" is not available
                        if (undefined != e) e.stop();

                        // show the appropriate error message
                        this.show_errors();

                    // if form validates but was submitted by calling the object's submit() method
                    // we check for the existence of "e" because the form can also be submitted by calling the
                    // submit() method, case in which "e" is not available
                    } else if (undefined == e) {

                        // submit the form
                        this.form.submit();

                    }

                }

            // change the scope of "this" so that we can have access to the Zebra_Form object's properties and methods
            }.bind(this));

        }

    },

	/**
	 *
	 */
    attach_tip: function(element, message)
    {
		
		// get element's ID
        var id = $(element).get('id');
		
		// set the message
        this.validation_rules[id].message = message;
		
		// show the error message
        this.show_errors(control);
    },

	/**
	 *
	 */
    dispose: function(element)
    {
		
		// get element's ID
        var id = element.get('id');
		
		// remove element from the validation queue
        delete this.validation_rules[id];
    },

    /**
     *
     */
    end_file_upload: function(element, file_info)
    {

        // if element exists and it has rules attached to it
        if ($(element) && undefined != this.validation_rules[element]) {

            var element = $(element);

            // get the element's ID
            var id = element.get('id');

            // delete the "target" attribute of the form
            this.form.erase('target');

            // remove from the DOM the attached IFrame
            $(id + '_iframe').destroy();

            // remove from the DOM the attached spinner
            $(id + '_spinner').destroy();

            // if
            if (

                // the method has a second argument
                undefined != file_info &&

                // the second argument is an object
                'object' == typeof(file_info) &&

                // the second argument is properly formatted
                undefined != file_info[0] &&
                undefined != file_info[1] &&
                undefined != file_info[2] &&
                undefined != file_info[3]

            ) {

                // set the second argument as a property of the element
                element.file_info = file_info;

            }

            // if control does not validate
            if (true !== this.validate_control(element)) {

                // clear the element's value
                element.value = '';

                // make the element visible (was hidden to show the spinner)
                element.setStyle('visibility', 'visible');

                // show the attached error message
                this.show_errors(element);

            // if control validates
            } else {

                // get the element's coordinates, relative to the form
                var coordinates = element.getCoordinates(this.form);

                // create a span control containing the file's name
                // which will replace the file upload control
                var file_name = new Element('span', {

                    'class': 'filename',
                    styles: {
                        'left': coordinates.left,
                        'top': coordinates.top,
                        'width': coordinates.width
                    }

                });

                // set the file's name as the content of the <span>
                file_name.set('html', file_info[0]);

                // add also an "close" button for canceling file upload
                var anchor = new Element('a', {

                    'href': 'javascript:void(0)'

                });

                anchor.set('html', 'x');

                anchor.addEvent('click', function(e) {

                    // stop default event
                    e.stop();

                    // remove the uploaded file's name from the DOM
                    file_name.destroy();

                    // clear the element's value
                    element.set('value', '');

                    // if the element has the "file_info" attribute set, remove it
                    if (undefined != element.file_info) element.removeAttribute('file_info');

                    // make the element visible
                    element.setStyle('visibility', 'visible');

                });

                // inject the "close" button
                anchor.inject(file_name);

                // inject everything into the DOM
                file_name.inject(this.form);

            }

        }

    },

	/**
	 *
	 */
    register: function(element)
    {

        // get some attributes of the element
        var attributes = element.getProperties('id', 'name', 'type');

        // sanitize element's name by removing square brackets (if available)
        attributes['name'] = attributes['name'].replace(/\[\]$/, '');

        // based on element's type...
        switch (attributes['type']) {

            // if element is a radio button or a checkbox
            case 'radio':
            case 'checkbox':

                // attach the function to the onClick and onBlur events
                element.addEvents({

                    'click': function() {this.hide_error(attributes['name'])}.bind(this),
                    'blur': function() {this.hide_error(attributes['name'])}.bind(this)

                });

                // we will also keep track of radio buttons and checkboxes sharing the same name
                if (undefined == this.controls_groups[attributes['id']]) {

                    // group together radio buttons and checkboxes sharing the same name
                    this.controls_groups[attributes['id']] = this.form.getElements('input[name^=' + attributes['name'] + ']');

                }

                break;

            // if element is file
            case 'file':

                // we replace the original control with a clone, as only file controls created dynamically from
                // javascript behave as expected

                // create a clone of the element (along with content and ID)
                var clone = element.clone(true, true);

                // unset the element's value
                clone.set('value', '');

                // replace the original element
                clone.replaces(element);

                clone.addEvents({

                    // attach a function to the onKeyPress event
                    'keypress': function(e) {

                        // stop event
                        e.stop();

                        // unset the element's value
                        clonse.value = '';

                    },

                    // attach a function to the onChange event
                    'change': function() {

                        this.hide_error(attributes['name']);

                        // if the "file_info" attribute is already set for the element
                        if (undefined != clone.file_info) {

                            // remove it
                            clone.removeAttribute('file_info');

                        }

                        // create an IFrame that we will use to submit the form to
                        var formIFrame = new IFrame({

                            id: attributes['id'] + '_iframe',
                            frameborder: 0,
                            marginheight: 0,
                            marginwidth: 0,
                            scrolling: 'no',
                            width: 0,
                            height: 0,
                            src: 'javascript:void(0)'

                        });

                        // inject the newly created IFrame into the DOM
                        formIFrame.inject(document.body);

                        // save the form's original action
                        var original_action = this.form.action;

                        // alter the action of the form
                        this.form.action =
                            this.options.process_path +
                            '?form=' + this.form_id +
                            '&control=' + attributes['id'] +
                            '&nocache=' + new Date().getTime();

                        // submit the form to the IFrame
                        this.form.target = attributes['id'] + '_iframe';

                        // hide the element
                        clone.setStyle('visibility', 'hidden');

                        // get element's coordinates
                        var coordinates = clone.getCoordinates();

                        // crate the spinner element
                        // and position it in the same position as the element
                        var spinner = new Element('div', {

                            'id': attributes['id'] + '_spinner',
                            'class':'Zebra_Form_spinner',
                            styles: {
                                left: coordinates.left,
                                top: coordinates.top
                            }

                        });

                        // inject the newly create element into the DOM
                        spinner.inject(document.body);

                        // submit the form
                        this.form.submit();

                        // restore the form's original action
                        this.form.action = original_action;

                    // change the scope of "this" so that we can have access to the
                    // Zebra_Form object's properties and methods
                    }.bind(this),

                    // attach a function to the onBlur event
                    'blur': function() {this.hide_error(attributes['name'])}.bind(this)

                });

                // element will now reference the clone
                element = clone;

                break;

            // if element is a select control (single or multi-values)
            case 'select-one':
            case 'select-multiple':

                // attach the function to the onChange and onBlur events
                element.addEvents({

                    'change': function() {this.hide_error(attributes['name'])}.bind(this),
                    'blur': function() {this.hide_error(attributes['name'])}.bind(this)

                });

                break;

            // for all other element types (text, textarea, password)
            default:

                // attach a function to the onBlur event
                element.addEvent('blur', function() {this.hide_error(attributes['name'])}.bind(this));

        }

        // get validation rules of the element
        var rules = element.get('class').match(/validate\[(.+)\]/);

        // if there are any rules
        if (null != rules) {

            // the regular expression used to "split" rules by comma
            var expr = /([^\,]*\(.*?\)|[^\,]+)/g;

            // this will be the list of rules for the current element
            var rules_list = new Object;

            // iterate over the rules
            while (matches = expr.exec(rules[1])) {

                // extract the rule's name
                var rule_name = matches[1].match(/^([^\(]+)/);

                // extract the rule's arguments
                var rule_arguments = matches[1].match(/\((.*?)\)/)

                // if there are any arguments to the rule
                if (rule_arguments) {

                    // split the arguments by commas into an array
                    rule_arguments = rule_arguments[1].split(',');

                    // iterate through the arguments
                    rule_arguments.each(function(argument, key) {

                        // replace some special entities set from PHP
                        rule_arguments[key] = rule_arguments[key].replace(/lsqb\;/g, '[');
                        rule_arguments[key] = rule_arguments[key].replace(/rsqb\;/g, ']');
                        rule_arguments[key] = rule_arguments[key].replace(/comma\;/g, ',');

                    });

                // if there are no arguments to the rule
                } else {

                    // treat arguments as "null"
                    rule_arguments = null;

                }

                // add the rule to the list of rules
                rules_list[rule_name[1]] = rule_arguments;

            }

            // if a second argument to the method was not provided
            // it means that the script will automatically need to figure out the order in which the element will be
            // validated, based on where it is in the DOM
            if (undefined == arguments[1]) {

                // get all the form's controls
                var elements = this.form.getElements('.control');

                // iterate through the form's controls
                elements.each(function(el, index) {

                    // if we've found the element we're registering
                    if (el == element) {

                        // we need to move backwards and find the previous control in the DOM

                        // the ID of the previous element
                        var previous_element_id = null;

                        // the previous control's position in the validation chain
                        var position = index - 1;

                        // while 
                        while (

                            // "previous_element_id" is null
                            previous_element_id == null &&

                            // a previous element exists
                            undefined != elements[position] &&

                            // the previous element doesn't have the "placeholder" class set
                            !elements[position].hasClass('placeholder')

                        ) {

                            // get the ID of the previous element
                            previous_element_id = elements[position].get('id');

                            // decrement position
                            position--;

                        }

                        // if a previous element doesn't exists
                        if (undefined == this.validation_rules[previous_element_id]) {

                            // create a temporary object
                            var tmp = new Object;

                            // assign the validation rules
                            tmp[attributes['id']] = {'element': element, 'rules': rules_list};

                            // if mootools version is 1.2.x
                            if (this.mootools_version == '1.2') {

                                // prepend the validation rules to the beginning of the "validation_rules" object
                                this.validation_rules = $merge(tmp, this.validation_rules);

                            // if mootools version is 1.3.x
                            } else {

                                // prepend the validation rules to the beginning of the "validation_rules" object
                                this.validation_rules = Object.merge(tmp, this.validation_rules);

                            }

                        // if a previous element does exist
                        } else {

                            // create a temporary object which will contain the reordered validation rules
                            var new_validation_rules = new Object;

                            // iterate through the already existing validation rules
                            for (index in this.validation_rules) {

                                // add each entry to the new array
                                new_validation_rules[index] = this.validation_rules[index];

                                // if we found the previous element
                                if (previous_element_id == index) {

                                    // append the validation rules for the current element
                                    new_validation_rules[attributes['id']] = {'element': element, 'rules': rules_list};

                                }

                            }

                            // copy the content of the temporary variable to the validation_rules property
                            this.validation_rules = new_validation_rules;

                        }

                    }

                // change the scope of "this" so that we can have access to the
                // Zebra_Form object's properties and methods
                }.bind(this));

            // if a second argument to the method was provided and it is an element
            // it means that the current control needs to be validated after that particular element
            } else if (undefined != arguments[1] && $(arguments[1])) {

                // get the ID of the element after which the current element needs to be validated
                var id = $(arguments[1]).get('id');

                // create a temporary object which will contain the reordered validation rules
                var new_validation_rules = new Object;

                // iterate through the already existing validation rules
                for (index in this.validation_rules) {

                    // add each entry to the new array
                    new_validation_rules[index] = this.validation_rules[index];

                    // if we found the previous element
                    if (previous_element_id == index) {

                        // append the validation rules for the current element
                        new_validation_rules[attributes['id']] = {'element': element, 'rules': rules_list};

                    }

                }

                // copy the content of the temporary variable to the validation_rules property
                this.validation_rules = new_validation_rules;

            // if a second argument to the method was provided and it is boolean false
            // it means that the element will be validated in the same order as it was registered
            } else if (undefined != arguments[1] && arguments[1] == false) {

                // add the validation rules for the current element
                this.validation_rules[attributes['id']] = {'element': element, 'rules': rules_list};

            }

        }

    },

    /**
     *
     */
    show_errors: function()
    {

        // hide all existing errors
        this.clear_errors();

        var counter = 0;

        // iterate through the validation rules
        for (index in this.validation_rules) {

            // current validation rule
            var validation_rule = this.validation_rules[index];

            // current element
            var element = validation_rule['element'];

            // get some attributes of the element
            var attributes = element.getProperties('id', 'name', 'type', 'name');

            // sanitize element's name by removing square brackets (if available)
            attributes['name'] = attributes['name'].replace(/\[\]$/, '');

            // sanitize element's name by removing square brackets (if available)
            attributes['name'] = attributes['name'].replace(/\[\]$/, '');

            // if the method has an element of the form as argument the current element is not that particular element,
            // skip the rest
            if (undefined != arguments[0] && arguments[0] != element) continue;

            // if element's value did not validate (there's an error message)
            if (undefined != validation_rule.message) {

                // focus the element (IE triggers an error if control has display:none)
                if (element.getStyle('display') != 'none') element.focus();

                // if element is hidden (it means that it's placeholder is currently visible)
                if (element.getStyle('display') == 'none') {

                    // get the placeholder's coordinates
                    var element_position = this.placeholders[attributes['id']].getCoordinates();

                // if element is visible
                } else {

                    // get element's coordinates
                    var element_position = element.getCoordinates();

                    // weird behaviour...
                    // if an item somewhere far below in a long list of a dropdown is selected, positions get messed up
                    // get element's scroll
                    var element_scroll = element.getScroll();

                    // if element is scrolled vertically
                    if (element_scroll.y != 0) {

                        // adjust it's top position
                        element_position.top += element_scroll.y;

                    }

                }

                // the main container holding the error message
                var container = new Element('div', {'class': 'Zebra_Form_error_message', styles: {opacity: 0}});

                // the container of the actual error message
                // width:auto is for IE6
                var message = new Element('div', {
                    'class': 'message' + (!this.options.close_tips ? ' noclose' : ''),
                    'style': 'width:auto'
                });

                // add the error message
                message.set('html', validation_rule.message);

                // add the message container to the main container
                message.inject(container);

                // if a "close" button is required
                if (this.options.close_tips) {

                    // create the close button
                    var close = new Element('a', {

                        'href': 'javascript:void(0)',
                        'class': 'close' + ((this.mootools_version == '1.2' && Browser.Engine.trident4) || (this.mootools_version == '1.3+' && Browser.ie6) ? '-ie6' : '')

                    });

                    // all it contains is an "x"
                    close.set('html', 'x');

                    // attach the events
                    close.addEvents({

                        'click': function(e) {e.stop(); this.hide_error(attributes['name'])}.bind(this),
                        'focus': function() {close.blur()}

                    });

                    // add the close button to the error message
                    close.inject(message);

                }

                // create the error messages's arrow
                var arrow = new Element('div', {'class': 'arrow'});

                // add it to the error message
                arrow.inject(container);

                // attach a tweening effect to the error message container
                container.set('tween', {

                    // for IE6, fading is not done correctly so we'll simply hide it instantly
                    duration: ((
                        (this.mootools_version == '1.2' && (Browser.Engine.trident4 || (Browser.Engine.gecko && Browser.Platform.mac))) ||
                        (this.mootools_version == '1.3+' && (Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac)))
                    ) ? 0 : 500),

                    onComplete: function() {

                        // if container is hidden
                        if (container.getStyle('opacity') == 0) {

                            // get a reference to the IFrame shim (if any)
                            var shim = container.retrieve('IframeShim');

                            // if an attached IFrame shim exists, remove it from the DOM
                            if (null != shim) shim.destroy();

                            // remove the container from the DOM
                            container.destroy()
                        }

                    }

                });

                // inject the error message into the DOM
                container.inject(document.body);

                // get container's size
                var container_size = container.getSize();

                // get arrow's size
                arrow_size = arrow.getSize();

                // set the arrow centered horizontally
                arrow.setStyle('left', (container_size.x / 2) - (arrow_size.x / 2) - 1);

                // the "left" of the container is set based on the "tips_position" property
                var left = (this.options.tips_position == 'left' ? element_position.left : element_position.right) - (container_size.x / 2);

                // if element is a radio button or a checkbox
                if (attributes['type'] == 'radio' || attributes['type'] == 'checkbox') {

                    // set the "left" of the container centered on the radio button/checkbox
                    left = element_position.right - (container_size.x / 2) - (element.getSize().x / 2) + 1;

                }

                // if "left" is outside the visible part of the page, adjust it
                if (left < 0) left = 2;

                // set left now because this might lead to text wrapping
                container.setStyle('left', left);

                // now get the size again
                container_size = container.getSize();

                // set the container's "top"
                var top = (element_position.top - container_size.y + (arrow_size.y / 2) - 1);

                // if "top" is outsude the visible part of the page, adjust it
                if (top < 0) top = 2;

                // set the final position of the container
                container.setStyles({
                    left:   left + 'px',
                    top:    top + 'px',
                    height: (container_size.y - (arrow_size.y / 2)) + 'px'
                });

                // create an IFrame shim for the container (only in IE6)
                var shimObj = new IframeShim(container, { display: true });

                // if the IFrame was created (only for IE6)
                if (undefined != shimObj.shim) {

                    // since 1.2.5 this is not set automatically and hence we have to set it manually
                    shimObj.shim.set('allowTransparency', 'true');

                    // also we have to remove this part...
                    shimObj.shim.set('style', shimObj.shim.get('style').replace(/filter.*?\;/i, ''));

                }

                // the name to save the error block by
                var id = (attributes['type'] == 'radio' || attributes['type'] == 'checkbox' ? attributes['name'] : attributes['id']);

                // add the error to the error blocks array
                this.error_blocks[id] = container;

                // the error message is slightly transparent
                container.tween('opacity', .9);

                // if this is the first error message, and we have to scroll to the it
                if (++counter == 1 && this.options.scroll_to_error) {

                    // scroll to the element
                    document.window.scrollTo(0, container.getStyle('top').replace(/px/, '') - 10);

                    // don't check any further
                    break;

                }

            }

        }

    },

	/**
	 *
	 */
    hide_error: function(element_name)
    {

        // if an error block exists for the element with the given id
        if (undefined != this.error_blocks[element_name]) {

            // fade out the error block
            // (which, on complete, destroys the IFrame shim - if it exists - and also the error block itself)
            this.error_blocks[element_name].tween('opacity', 0);

        }

    },

	/**
	 *
	 */
    clear_errors: function()
    {

        // iterate through all the error block
        for (block in this.error_blocks) {

            // get the instance of the attached IFrame shim (if available)
            var shim = this.error_blocks[block].retrieve('IframeShim');

            // if there is an IFrame shim attached, destroy it
            if (null != shim) shim.destroy();

            // destroy the error block
            this.error_blocks[block].destroy();

        }

    },

	/**
	 *
	 */
    submit: function()
    {

        // if there are any controls that require validation
        if (undefined != this.options.error_messages)

            // fire the form's submit event manually
            this.form.fireEvent('submit');

        // otherwise
        else

            // submit the form natively
            this.form.submit();

    },

	/**
	 *
	 */
    validate_control: function(element)
    {

        // get the ID and the type of the element
        var attributes = element.getProperties('id', 'type');

        // by default, we assume the control validates
        var control_is_valid = true;

        // get the control's validation rules
        var validation_rules = this.validation_rules[attributes['id']];

        // if a rule is not passed, this variable hold the name of that rule
        var rule_not_passed = null;

        // delete any error messages for the current control
        delete validation_rules.message;

        // iterate through the validation rules
        for (var rule in validation_rules['rules']) {

            // if control is not valid, do not look further
            if (!control_is_valid) break;

            // check the rule's name
            switch (rule) {

                case 'alphabet':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // the regular expression to use:
                            // a-z plus additional characters (if any), case-insensitive
                            var exp = new RegExp('^[a-z' + validation_rules['rules'][rule][0].escapeRegExp().replace(/\s/, '\\s') + ']+$', 'ig');

                            // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                            if (element.value.trim() != '' && !exp.test(element.value)) control_is_valid = false;

                            break;

                    }

                    break;

                case 'alphanumeric':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // the regular expression to use:
                            // a-z, 0-9 plus additional characters (if any), case-insensitive
                            var exp = new RegExp('^[a-z0-9' + validation_rules['rules'][rule][0].escapeRegExp().replace(/\s/, '\\s') + ']+$', 'ig');

                            // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                            if (element.value.trim() != '' && !exp.test(element.value)) control_is_valid = false;

                            break;

                    }

                    break;

                case 'compare':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // if 
                            if (

                                // element to compare with doesn't exist OR
                                !$(validation_rules['rules'][rule][0]) ||

                                (

                                    // element to compare with exists 
                                    $(validation_rules['rules'][rule][0]) &&

                                    // but it doesn't have the same value as the current element's value
                                    element.value != $(validation_rules['rules'][rule][0]).value

                                )

                            // the rule doesn't validate
                            ) control_is_valid = false;

                            break;

                    }

                    break;

                case 'custom':

                    var break_inner_loop = false;

                    // iterate through the custom functions
                    validation_rules['rules'][rule].each(function(func) {

                        // exit if we don't need to look any further
                        if (break_inner_loop) return;

                        // run the function against the element's value
                        control_is_valid = window[func](element.value);

                        // if the rule doesn't validate, don't check the other custom functions
                        if (!control_is_valid) break_inner_loop = true;

                    });

                    break;

                case 'date':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'text':

                            // if element has a value
                            if (element.value.trim() != '') {

                                // by default, we assume the date is invalid
                                var valid_date = false;

                                // get the required date format
                                var format = element.format.replace(/\s/g, '');

                                // escape characters that could have special meaning in a regular expression
                                format = format.escapeRegExp();

                                // allowed characters in date's format
                                var format_chars = ['d','D','j','l','N','S','w','F','m','M','n','Y','y','G','H','g','h','a','A','i','s','U'];

                                // this array will contain the characters defining the date's format
                                var matches = new Array;

                                // iterate through the allowed characters in date's format
                                for (var i = 0; i < format_chars.length; i++) {

                                    // if character is found in the date's format
                                    if ((position = format.indexOf(format_chars[i])) > -1) {

                                        // save it, alongside the character's position
                                        matches.push({character: format_chars[i], position: position});

                                    }
                                }

                                // sort characters defining the date's format based on their position, ascending
                                matches.sort(function(a, b){ return a.position - b.position });

                                // this array will contain the regular expression built for each of the characters
                                // used in the date's format
                                var regexp = new Array;

                                // iterate through the characters defining the date's format
                                matches.each(function(match, index) {

                                    // add to the array of regular expressions, based on the character
                                    switch (match.character) {

                                        case 'd': regexp.push('0[1-9]|[12][0-9]|3[01]'); break;
                                        case 'D': regexp.push('[a-z]{3}'); break;
                                        case 'j': regexp.push('[1-9]|[12][0-9]|3[01]'); break;
                                        case 'l': regexp.push('[a-z]+'); break;
                                        case 'N': regexp.push('[1-7]'); break;
                                        case 'S': regexp.push('st|nd|rd|th'); break;
                                        case 'w': regexp.push('[0-6]'); break;
                                        case 'F': regexp.push('[a-z]+'); break;
                                        case 'm': regexp.push('0[1-9]|1[012]+'); break;
                                        case 'M': regexp.push('[a-z]{3}'); break;
                                        case 'n': regexp.push('[1-9]|1[012]'); break;
                                        case 'Y': regexp.push('[0-9]{4}'); break;
                                        case 'y': regexp.push('[0-9]{2}'); break;
                                        case 'G':
                                        case 'H':
                                        case 'g':
                                        case 'h': regexp.push('[0-9]{1,2}'); break;
                                        case 'a':
                                        case 'A': regexp.push('(am|pm)'); break;
                                        case 'i':
                                        case 's': regexp.push('[012345][0-9]'); break;

                                    }

                                });

                                // if we have an array of regular expressions
                                if (regexp.length > 0) {

                                    // we will replace characters in the date's format in reversed order
                                    matches.reverse();

                                    // iterate through the characters in date's format
                                    matches.each(function(match, index) {

                                        // replace each character with the appropriate regular expression
                                        format = format.replace(match.character, '(' + regexp[regexp.length - index - 1] + ')');

                                    });

                                    // the final regular expressiom
                                    regexp = new RegExp('^' + format + '$', 'ig');

                                    // if regular expression was matched
                                    if ((segments = regexp.exec(element.value.replace(/\s/g, '')))) {

                                        // check if date is a valid date (i.e. there's no February 31)

                                        var original_day = null;
                                        var original_month = null;
                                        var original_year = null;
                                        var english_days   = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
                                        var english_months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
                                        var iterable = null;

                                        // reverse back the characters in the date's format
                                        matches.reverse();

                                        // by default, we assume the date is valid
                                        var valid = true;

                                        // iterate through the characters in the date's format
                                        matches.each(function(match, index) {

                                            // if the date is not valid, don't look further
                                            if (!valid) return true;

                                            // based on the character
                                            switch (match.character) {

                                                case 'm':
                                                case 'n':

                                                    // extract the month from the value entered by the user
                                                    original_month = parseInt(segments[index + 1], 10);

                                                    break;

                                                case 'd':
                                                case 'j':

                                                    // extract the day from the value entered by the user
                                                    original_day = parseInt(segments[index + 1], 10);

                                                    break;

                                                case 'D':
                                                case 'l':
                                                case 'F':
                                                case 'M':

                                                    // if day is given as day name, we'll check against the names in the used language
                                                    if (match.character == 'D' || match.character == 'l') iterable = window['calendar_' + id].options.days;

                                                    // if month is given as month name, we'll check against the names in the used language
                                                    else iterable = window['calendar_' + id].options.months;

                                                    // by default, we assume the day or month was not entered correctly
                                                    valid = false;

                                                    // iterate through the month/days in the used language
                                                    iterable.each(function(value, key) {

                                                        // if month/day was entered correctly, don't look further
                                                        if (valid) return true;

                                                        // if month/day was entered correctly
                                                        if (segments[index + 1].toLowerCase() == value.substring(0, (match.character == 'D' || match.character == 'M' ? 3 : value.length)).toLowerCase()) {

                                                            // extract the day/month from the value entered by the user
                                                            switch (match.character) {

                                                                case 'D': segments[index + 1] = english_days[key].substring(0, 3); break;
                                                                case 'l': segments[index + 1] = english_days[key]; break;
                                                                case 'F': segments[index + 1] = english_months[key]; original_month = key; break;
                                                                case 'M': segments[index + 1] = english_months[key].substring(0, 3); original_month = key; break;

                                                            }

                                                            // day/month value is valid
                                                            valid = true;

                                                        }

                                                    });

                                                    break;

                                                case 'Y':

                                                    // extract the year from the value entered by the user
                                                    original_year = parseInt(segments[index + 1], 10);

                                                    break;

                                                case 'y':

                                                    // extract the year from the value entered by the user
                                                    original_year = '19' + parseInt(segments[index + 1], 10);

                                                    break;

                                            }
                                        });

                                        // if everything was ok so far
                                        if (valid) {

                                            // generate a Date object using the values entered by the user
                                            var date = new Date(original_year, original_month - 1, original_day);

                                            // if, after that, the date is the same as the date entered by the user
                                            if (date.getFullYear() == original_year && date.getDate() == original_day && date.getMonth() == (original_month - 1)) {

                                                // set the timestamp as a property of the element
                                                element.timestamp = Date.parse(english_months[original_month - 1] + ' ' + original_day + ', ' + original_year);

                                                // date is valid
                                                valid_date = true;

                                            }

                                        }

                                    }

                                }

                                // if date is not valid, the rule doesn't validate
                                if (!valid_date) control_is_valid = false;

                            }

                        break;
                    }

                    break;

                case 'datecompare':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // if
                            if (

                                // rule is setup correctly
                                undefined != validation_rules['rules'][rule][0] &&
                                undefined != validation_rules['rules'][rule][1] &&

                                // element to compare to exists
                                $(validation_rules['rules'][rule][0]) &&

                                // element to compare to has a valid date as the value
                                this.validate_control($(validation_rules['rules'][rule][0])) === true &&

                                // current element was validated and contains a valid date as the value
                                undefined != element.timestamp

                            ) {

                                // compare the two dates according to the comparison operator
                                switch (validation_rules['rules'][rule][1]) {

                                    case '>':

                                        control_is_valid = (element.timestamp > $(validation_rules['rules'][rule][0]).timestamp);
                                        break;

                                    case '>=':

                                        control_is_valid = (element.timestamp >= $(validation_rules['rules'][rule][0]).timestamp);
                                        break;

                                    case '<':

                                        control_is_valid = (element.timestamp < $(validation_rules['rules'][rule][0]).timestamp);
                                        break;

                                    case '<=':

                                        control_is_valid = (element.timestamp <= $(validation_rules['rules'][rule][0]).timestamp);
                                        break;

                                }

                            }

                            break;

                    }

                    break;

                case 'digits':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // the regular expression to use:
                            // 0-9 plus additional characters (if any)
                            var exp = new RegExp('^[0-9' + validation_rules['rules'][rule][0].escapeRegExp().replace(/\s/, '\\s') + ']+$', 'ig');

                            // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                            if (element.value.trim() != '' && !exp.test(element.value)) control_is_valid = false;

                            break;
                    }

                    break;

                case 'email':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                            if (element.value.trim() != '' && null == element.value.match(/^([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+@{1}([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+\.[A-Za-z0-9]{2,}$/)) control_is_valid = false;

                            break;
                    }

                    break;

                case 'emails':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // split addresses by commas
                            var addresses = element.value.split(',');

                            // iterate through the email addresses
                            addresses.each(function(address) {

                                // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                                if (address.trim() != '' && null == address.trim().match(/^([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+@{1}([a-zA-Z0-9_\-\+\~\^\{\}]+[\.]?)+\.[A-Za-z0-9]{2,}$/)) control_is_valid = false;

                            });

                            break;

                    }

                    break;

                case 'filesize':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'file':

                            // if a file was uploaded
                            if (undefined != element.file_info) {

                                // if
                                if (

                                    // there's something wrong with the uploaded file
                                    undefined == element.file_info[2] ||
                                    undefined == element.file_info[3] ||

                                    // there was a specific error while uploading the file
                                    element.file_info[2] != 0 ||

                                    // the uploaded file's size is larger than the allowed size
                                    parseInt(element.file_info[3], 10) > parseInt(validation_rules['rules'][rule][0], 10)

                                // the rule doesn't validate
                                ) control_is_valid = false;

                            }

                            break;
                    }

                    break;

                case 'float':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // the regular expression to use:
                            // only digits (0 to 9) and/or one dot (but not as the very first character) and/or one minus sign
                            // (but only if it is the very first character) plus characters given as additional characters (if any).
                            var exp = new RegExp('^[0-9\-\.' + validation_rules['rules'][rule][0].escapeRegExp().replace(/\s/, '\\s') + ']+$', 'ig');

                            // if
                            if (

                                // value is not an empty string
                                element.value.trim() != '' &&

                                (

                                    // value is a minus sign
                                    element.value.trim() == '-' ||

                                    // value is a dot
                                    element.value.trim() == '.' ||

                                    // there are more than one minus signs
                                    (null != element.value.match(/\-/g) && element.value.match(/\-/g).length > 1) ||

                                    // there are more than one dots
                                    (null != element.value.match(/\./g) && element.value.match(/\./g).length > 1) ||

                                    // if the minus sign is not the very first character
                                    element.value.indexOf('-') > 0 ||

                                    // the regular expression is not matched
                                    !exp.test(element.value)

                                )

                            // the rule doesn't validate
                            ) control_is_valid = false;

                            break;

                    }

                    break;

                case 'image':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'file':

                            // if
                            if (

                                // a file was uploaded
                                undefined != element.file_info &&

                                // uploaded file is not a valid image type
                                null == element.file_info[1].match(/image\/(gif|jpeg|png|pjpeg)/i)

                            // the rule doesn't validate
                            ) control_is_valid = false;

                            break;

                    }

                    break;

                case 'length':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // if
                            if (

                                // lower limit is given and the length of entered value is smaller than it
                                (undefined != validation_rules['rules'][rule][0] && element.value.trim().length < validation_rules['rules'][rule][0]) ||

                                // upper limit is given and the length of entered value is greater than it
                                (undefined != validation_rules['rules'][rule][1] && validation_rules['rules'][rule][1] > 0 && element.value.length > validation_rules['rules'][rule][1])

                            // the rule doesn't validate
                            ) control_is_valid = false;

                            break;

                    }

                    break;

                case 'number':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // the regular expression to use:
                            // digits (0 to 9) and/or one minus sign (but only if it is the very first character) plus
                            // characters given as additional characters (if any).
                            var exp = new RegExp('^[0-9\-' + validation_rules['rules'][rule][0].escapeRegExp().replace(/\s/, '\\s') + ']+$', 'ig');

                            // if
                            if (

                                // value is not an empty string
                                element.value.trim() != '' &&

                                (

                                    // value is a minus sign
                                    element.value.trim() == '-' ||

                                    // there are more than one minus signs
                                    (null != element.value.match(/\-/g) && element.value.match(/\-/g).length > 1) ||

                                    // the minus sign is not the very first character
                                    element.value.indexOf('-') > 0 ||

                                    // the regular expression is not matched
                                    !exp.test(element.value)

                                )

                            // the rule doesn't validate
                            ) control_is_valid = false;

                            break;

                    }

                    break;

                case 'regexp':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'password':
                        case 'text':
                        case 'textarea':

                            // the regular expression to use
                            var exp = new RegExp(validation_rules['rules'][rule][0], 'g');

                            // if value is not an empty string and the regular expression is not matched, the rule doesn't validate
                            if (element.value.trim() != '' && null == exp.exec(element.value)) control_is_valid = false;

                            break;

                    }

                    break;

                case 'required':

                    // if element type is one of the following
                    switch (attributes['type']) {

                        case 'checkbox':
                        case 'radio':

                            // by default, we assume there's nothing checked
                            var checked = false;

                            // iterate through the controls sharing the same name as the current element
                            this.controls_groups[attributes['id']].each(function(el) {

                                // if any of them is checked set a flag
                                if (el.checked) checked = true;

                            });

                            // if nothing is checked, the rule doesn't validate
                            if (!checked) control_is_valid = false;

                            break;

                        case 'file':
                        case 'password':
                        case 'text':
                        case 'textarea':

                            // if value is am empty string, the rule doesn't validate
                            if (element.value.trim() == '') control_is_valid = false;

                            break;

                        case 'select-one':

                            if (

                                // if 
                                (

                                    // the "other" attribute is set
                                    element.hasClass('other') &&

                                    // the "other" value is set
                                    element.value == 'other' &&

                                    // nothing is entered in the attached "other" field
                                    (!$(id + '_other') || $(id + '_other').value.trim() == '')

                                ) ||

                                // nothing is selected
                                element.selectedIndex == 0

                            // the rule doesn't validate
                            ) control_is_valid = false;

                            break;

                        case 'select-multiple':

                            // if nothing is selected, the rule doesn't validate
                            if (element.selectedIndex == -1) control_is_valid = false;

                            break;

                    }

                    break;

            }

            // if the rule didn't validate
            if (!control_is_valid) {

                // the name of the rule that didn't validate
                rule_not_passed = rule

                // set the error message's text
                validation_rules.message = this.options.error_messages[attributes['id']][rule_not_passed];

                // save the element's value
                validation_rules.value = element.value;

            }

        }

        // return TRUE if the all the rules were obeyed or the name of the rule if a rule didn't validate
        return (control_is_valid ? true : rule_not_passed);

    },

	/**
	 *
	 */
    validate: function()
    {

        var control = null;
        var id = null;

        // by default, we assume the form validates
        var form_is_valid = true;

        // iterate through all the validation rules
        for (index in this.validation_rules) {

            // if form is not valid, don't check any further
            if (!form_is_valid) break;

            // get the element that needs to be validated
            element = this.validation_rules[index]['element'];

            // get the element's ID
            id = element.get('id');

            // if element does not validate
            if ((rule_not_passed = this.validate_control(element)) !== true) {

                // the form is not valid
                form_is_valid = false;

                // don't check other controls
                break;

            }

        }

        // if form validates and there's an onValid function to be run, run it
        if (form_is_valid && undefined != this.options.onValid) return this.options.onValid();

        // return the result of the validation
        return form_is_valid;

    }

});


// Calendar: a Javascript class for Mootools that adds accessible and unobtrusive date pickers to your form elements <http://electricprism.com/aeron/calendar>
// Calendar RC4, Copyright (c) 2007 Aeron Glemann <http://electricprism.com/aeron>, MIT Style License.
// Mootools 1.2 compatibility by Davorin A ego

var Calendar = new Class({

  Implements: Options,

    options: {
        blocked: [], // blocked dates
        classes: [], // ['calendar', 'prev', 'next', 'month', 'year', 'today', 'invalid', 'valid', 'inactive', 'active', 'hover', 'hilite']
        days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // days of the week starting at sunday
        direction: 0, // -1 past, 0 past + future, 1 future
        draggable: false,
        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        navigation: 1, // 0 = no nav; 1 = single nav for month; 2 = dual nav for month and year
        offset: 0, // first day of the week: 0 = sunday, 1 = monday, etc..
        onHideStart: Class.empty,
        onHideComplete: Class.empty,
        onShowStart: Class.empty,
        onShowComplete: Class.empty,
        pad: 0, // padding between multiple calendars
        tweak: {x: -100, y: 0} // tweak calendar positioning
    },

    // initialize: calendar constructor
    // @param obj (obj) a js object containing the form elements and format strings { id: 'format', id: 'format' etc }
    // @param props (obj) optional properties

    initialize: function(obj, options) {
        // basic error checking
        if (!obj) { return false; }

        this.setOptions(options);

        // detect MooTools version
        this.mootools_version = (typeof $extend == 'function' ? '1.2' : '1.3+');

        // if mootools version is 1.3+ but not using the compatibility mode
        if (this.mootools_version == '1.3+' && typeof Function.create != 'function') {

            // implement the "create" method
            Function.implement({
                create: function(options){
                    var self = this;
                    options = options || {};
                    return function(event) {
                        var args = options.arguments;
                        args = (args != undefined) ? Array.from(args) : Array.slice(arguments, (options.event) ? 1 : 0);
                        if (options.event) args = [event || window.event].append(args);
                        var returns = function() {
                            return self.apply(options.bind || null, args);
                        }
                        return returns();
                    }
                }
            })

        }

        // create our classes array
        var keys = ['calendar', 'prev', 'next', 'month', 'year', 'today', 'invalid', 'valid', 'inactive', 'active', 'hover', 'hilite'];

        var values = keys.map(function(key, i) {
            if (this.options.classes[i]) {
                if (this.options.classes[i].length) { key = this.options.classes[i]; }
            }
            return key;
        }, this);

        this.classes = values.associate(keys);

        // create cal element with css styles required for proper cal functioning
        this.calendar = new Element('div', {
            'styles': { left: '-1000px', opacity: 0, position: 'absolute', top: '-1000px', zIndex: 1000 }
        }).addClass(this.classes.calendar).inject(document.body);

        // iex 6 needs a transparent iframe underneath the calendar in order to not allow select elements to render through
        if (
            (this.mootools_version == '1.2' && (Browser.Engine.trident4 || (Browser.Engine.gecko && Browser.Platform.mac))) ||
            (this.mootools_version == '1.3+' && (Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac)))
        ) {
            this.iframe = new Element('iframe', {
                'styles': { left: '-1000px', position: 'absolute', top: '-1000px', zIndex: 999 }
            }).inject(document.body);
            this.iframe.style.filter = 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)';
        }

        // initialize fade method
        this.fx = new Fx.Tween(this.calendar, {
            duration: ((this.mootools_version == '1.2' && Browser.Engine.trident) || (this.mootools_version == '1.3+' && (Browser.ie)) ? 0 : 250),
            onStart: function() {
                if (this.calendar.getStyle('opacity') == 0) { // show
                    if (
                        (this.mootools_version == '1.2' && (Browser.Engine.trident4 || (Browser.Engine.gecko && Browser.Platform.mac))) ||
                        (this.mootools_version == '1.3+' && (Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac)))
                    ) { this.iframe.setStyle('display', 'block') }
                    this.calendar.setStyle('display', 'block');
                    this.fireEvent('onShowStart', this.element);
                }
                else { // hide
                    this.fireEvent('onHideStart', this.element);
                }
            }.bind(this),
            onComplete: function() {
                if (this.calendar.getStyle('opacity') == 0) { // hidden
                    this.calendar.setStyle('display', 'none');
                    if (
                        (this.mootools_version == '1.2' && (Browser.Engine.trident4 || (Browser.Engine.gecko && Browser.Platform.mac))) ||
                        (this.mootools_version == '1.3+' && (Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac)))
                    ) { this.iframe.setStyle('display', 'none') }
                    this.fireEvent('onHideComplete', this.element);
                }
                else { // shown
                    this.fireEvent('onShowComplete', this.element);
                }
            }.bind(this)
        });

        // initialize drag method
        if (window.Drag && this.options.draggable) {
            this.drag = new Drag.Move(this.calendar, {
                onDrag: function() {
                    if (
                        (this.mootools_version == '1.2' && (Browser.Engine.trident4 || (Browser.Engine.gecko && Browser.Platform.mac))) ||
                        (this.mootools_version == '1.3+' && (Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac)))
                    ) { this.iframe.setStyles({ left: this.calendar.style.left, top: this.calendar.style.top }) }
                }.bind(this)
            });
        }

        // create calendars array
        this.calendars = [];

        var id = 0;
        var d = new Date(); // today

        d.setDate(d.getDate() + this.options.direction.toInt()); // correct today for directional offset

        for (var i in obj) {
            var cal = {
                button: new Element('button', { 'type': 'button' }),
                el: $(i),
                els: [],
                id: id++,
                month: d.getMonth(),
                visible: false,
                year: d.getFullYear()
            };

            // fix for bad element (naughty, naughty element!)
            if (!this.element(i, obj[i], cal)) { continue; }

            cal.el.addClass(this.classes.calendar);

            // create cal button
            cal.button.addClass(this.classes.calendar).addEvent('click', function(cal) { this.toggle(cal); }.pass(cal, this)).inject(cal.el, 'after');

            // read in default value
            cal.val = this.read(cal);

            if (this.mootools_version == '1.2') {
                $extend(cal, this.bounds(cal)); // abs bounds of calendar
            } else {
                Object.append(cal, this.bounds(cal)); // abs bounds of calendar
            }

            if (this.mootools_version == '1.2') {
                $extend(cal, this.values(cal)); // valid days, months, years
            } else {
                Object.append(cal, this.values(cal)); // valid days, months, years
            }

            this.rebuild(cal);

            this.calendars.push(cal); // add to cals array
        }
    },


    // blocked: returns an array of blocked days for the month / year
    // @param cal (obj)
    // @returns blocked days (array)

    blocked: function(cal) {
        var blocked = [];
        var offset = new Date(cal.year, cal.month, 1).getDay(); // day of the week (offset)
        var last = new Date(cal.year, cal.month + 1, 0).getDate(); // last day of this month

        this.options.blocked.each(function(date){
            var values = date.split(' ');

            // preparation
            for (var i = 0; i <= 3; i++){
                if (!values[i]){ values[i] = (i == 3) ? '' : '*'; } // make sure blocked date contains values for at least d, m and y
                values[i] = values[i].contains(',') ? values[i].split(',') : new Array(values[i]); // split multiple values
                var count = values[i].length - 1;
                for (var j = count; j >= 0; j--){
                    if (values[i][j].contains('-')){ // a range
                        var val = values[i][j].split('-');
                        for (var k = val[0]; k <= val[1]; k++){
                            if (!values[i].contains(k)){ values[i].push(k + ''); }
                        }
                        values[i].splice(j, 1);
                    }
                }
            }

            // execution
            if (values[2].contains(cal.year + '') || values[2].contains('*')){
                if (values[1].contains(cal.month + 1 + '') || values[1].contains('*')){
                    values[0].each(function(val){ // if blocked value indicates this month / year
                        if (val > 0){ blocked.push(val.toInt()); } // add date to blocked array
                    });

                    if (values[3]){ // optional value for day of week
                        for (var i = 0; i < last; i++){
                                var day = (i + offset) % 7;

                                if (values[3].contains(day + '')){
                                    blocked.push(i + 1); // add every date that corresponds to the blocked day of the week to the blocked array
                                }
                        }
                    }
                }
            }
        }, this);

        return blocked;
    },


    // bounds: returns the start / end bounds of the calendar
    // @param cal (obj)
    // @returns obj

    bounds: function(cal) {
        // 1. first we assume the calendar has no bounds (or a thousand years in either direction)

        // by default the calendar will accept a millennium in either direction
        var start = new Date(1000, 0, 1); // jan 1, 1000
        var end = new Date(2999, 11, 31); // dec 31, 2999

        // 2. but if the cal is one directional we adjust accordingly
        var date = new Date().getDate() + this.options.direction.toInt();

        if (this.options.direction > 0) {
            start = new Date();
            start.setDate(date + this.options.pad * cal.id);
        }

        if (this.options.direction < 0) {
            end = new Date();
            end.setDate(date - this.options.pad * (this.calendars.length - cal.id - 1));
        }

        // 3. then we can further filter the limits by using the pre-existing values in the selects
        cal.els.each(function(el) {
            if (el.get('tag') == 'select') {
                if (el.format.test('(y|Y)')) { // search for a year select
                    var years = [];

                    el.getChildren().each(function(option) { // get options
                        var values = this.unformat(option.value, el.format);

                        if (!years.contains(values[0])) { years.push(values[0]); } // add to years array
                    }, this);

                    years.sort(this.sort);

                    if (years[0] > start.getFullYear()) {
                        d = new Date(years[0], start.getMonth() + 1, 0); // last day of new month

                        if (start.getDate() > d.getDate()) { start.setDate(d.getDate()); }

                        start.setYear(years[0]);
                    }

                    if (years.getLast() < end.getFullYear()) {
                        d = new Date(years.getLast(), end.getMonth() + 1, 0); // last day of new month

                        if (end.getDate() > d.getDate()) { end.setDate(d.getDate()); }

                        end.setYear(years.getLast());
                    }
                }

                if (el.format.test('(F|m|M|n)')) { // search for a month select
                    var months_start = [];
                    var months_end = [];

                    el.getChildren().each(function(option) { // get options
                        var values = this.unformat(option.value, el.format);

                        if (
                            (
                                (this.mootools_version == '1.3+' && typeOf(values[0]) == 'number') ||
                                (this.mootools_version == '1.2' && $type(values[0]) == 'number')
                            )
                            || values[0] == years[0]
                        ) { // if it's a year / month combo for curr year, or simply a month select
                            if (!months_start.contains(values[1])) { months_start.push(values[1]); } // add to months array
                        }

                        if (
                            (
                                (this.mootools_version == '1.3+' && typeOf(values[0]) == 'number') ||
                                (this.mootools_version == '1.2' && $type(values[0]) == 'number')
                            ) ||
                            values[0] == years.getLast()) { // if it's a year / month combo for curr year, or simply a month select
                            if (!months_end.contains(values[1])) { months_end.push(values[1]); } // add to months array
                        }
                    }, this);

                    months_start.sort(this.sort);
                    months_end.sort(this.sort);

                    if (months_start[0] > start.getMonth()) {
                        d = new Date(start.getFullYear(), months_start[0] + 1, 0); // last day of new month

                        if (start.getDate() > d.getDate()) { start.setDate(d.getDate()); }

                        start.setMonth(months_start[0]);
                    }

                    if (months_end.getLast() < end.getMonth()) {
                        d = new Date(start.getFullYear(), months_end.getLast() + 1, 0); // last day of new month

                        if (end.getDate() > d.getDate()) { end.setDate(d.getDate()); }

                        end.setMonth(months_end.getLast());
                    }
                }
            }
        }, this);

        return { 'start': start, 'end': end };
    },


    // caption: returns the caption element with header and navigation
    // @param cal (obj)
    // @returns caption (element)

    caption: function(cal) {
        // start by assuming navigation is allowed
        var navigation = {
            prev: { 'month': true, 'year': true },
            next: { 'month': true, 'year': true }
        };

        // if we're in an out of bounds year
        if (cal.year == cal.start.getFullYear()) {
            navigation.prev.year = false;
            if (cal.month == cal.start.getMonth() && this.options.navigation == 1) {
                navigation.prev.month = false;
            }
        }
        if (cal.year == cal.end.getFullYear()) {
            navigation.next.year = false;
            if (cal.month == cal.end.getMonth() && this.options.navigation == 1) {
                navigation.next.month = false;
            }
        }

        // special case of improved navigation but months array with only 1 month we can disable all month navigation
        if (
            (this.mootools_version == '1.3+' && typeOf(cal.months) == 'array') ||
            (this.mootools_version == '1.2' && $type(cal.months) == 'array')
        ) {
            if (cal.months.length == 1 && this.options.navigation == 2) {
                navigation.prev.month = navigation.next.month = false;
            }
        }

        var caption = new Element('caption');

        var prev = new Element('a').addClass(this.classes.prev).appendText('\x3c'); // <
        var next = new Element('a').addClass(this.classes.next).appendText('\x3e'); // >

        if (this.options.navigation == 2) {
            var month = new Element('span').addClass(this.classes.month).inject(caption);

            if (navigation.prev.month) { prev.clone().addEvent('click', function(cal) { this.navigate(cal, 'm', -1); }.pass(cal, this)).inject(month); }

            month.adopt(new Element('span').appendText(this.options.months[cal.month]));

            if (navigation.next.month) { next.clone().addEvent('click', function(cal) { this.navigate(cal, 'm', 1); }.pass(cal, this)).inject(month); }

            var year = new Element('span').addClass(this.classes.year).inject(caption);

            if (navigation.prev.year) { prev.clone().addEvent('click', function(cal) { this.navigate(cal, 'y', -1); }.pass(cal, this)).inject(year); }

            year.adopt(new Element('span').appendText(cal.year));

            if (navigation.next.year) { next.clone().addEvent('click', function(cal) { this.navigate(cal, 'y', 1); }.pass(cal, this)).inject(year); }
        }
        else { // 1 or 0
            if (navigation.prev.month && this.options.navigation) { prev.clone().addEvent('click', function(cal) { this.navigate(cal, 'm', -1); }.pass(cal, this)).inject(caption); }

            caption.adopt(new Element('span').addClass(this.classes.month).appendText(this.options.months[cal.month]));

            caption.adopt(new Element('span').addClass(this.classes.year).appendText(cal.year));

            if (navigation.next.month && this.options.navigation) { next.clone().addEvent('click', function(cal) { this.navigate(cal, 'm', 1); }.pass(cal, this)).inject(caption); }

        }

        return caption;
    },


    // changed: run when a select value is changed
    // @param cal (obj)

    changed: function(cal) {
        cal.val = this.read(cal); // update calendar val from inputs

        if (this.mootools_version == '1.2') {
            $extend(cal, this.values(cal)); // update bounds - based on curr month
        } else {
            Object.append(cal, this.values(cal)); // update bounds - based on curr month
        }

        this.rebuild(cal); // rebuild days select

        if (!cal.val) { return; } // in case the same date was clicked the cal has no set date we should exit

        if (cal.val.getDate() < cal.days[0]) { cal.val.setDate(cal.days[0]); }
        if (cal.val.getDate() > cal.days.getLast()) { cal.val.setDate(cal.days.getLast()); }

        cal.els.each(function(el) {    // then we can set the value to the field
            el.value = this.format(cal.val, el.format);
        }, this);

        this.check(cal); // checks other cals

        this.calendars.each(function(kal) { // update cal graphic if visible
            if (kal.visible) { this.display(kal); }
        }, this);
    },


    // check: checks other calendars to make sure no overlapping values
    // @param cal (obj)

    check: function(cal) {
        this.calendars.each(function(kal, i) {
            if (kal.val) { // if calendar has value set
                var change = false;

                if (i < cal.id) { // preceding calendar
                    var bound = new Date(Date.parse(cal.val));

                    bound.setDate(bound.getDate() - (this.options.pad * (cal.id - i)));

                    if (bound < kal.val) { change = true; }
                }
                if (i > cal.id) { // following calendar
                    var bound = new Date(Date.parse(cal.val));

                    bound.setDate(bound.getDate() + (this.options.pad * (i - cal.id)));

                    if (bound > kal.val) { change = true; }
                }

                if (change) {
                    if (kal.start > bound) { bound = kal.start; }
                    if (kal.end < bound) { bound = kal.end; }

                    kal.month = bound.getMonth();
                    kal.year = bound.getFullYear();

                    if (this.mootools_version == '1.2') {
                        $extend(kal, this.values(kal));
                    } else {
                        Object.append(kal, this.values(kal));
                    }

                    // TODO - IN THE CASE OF SELECT MOVE TO NEAREST VALID VALUE
                    // IN THE CASE OF INPUT DISABLE

                    // if new date is not valid better unset cal value
                    // otherwise it would mean incrementally checking to find the nearest valid date which could be months / years away
                    kal.val = kal.days.contains(bound.getDate()) ? bound : null;

                    this.write(kal);

                    if (kal.visible) { this.display(kal); } // update cal graphic if visible
                }
            }
            else {
                kal.month = cal.month;
                kal.year = cal.year;
            }
        }, this);
    },


    // clicked: run when a valid day is clicked in the calendar
    // @param cal (obj)

    clicked: function(td, day, cal) {
        cal.val = (this.value(cal) == day) ? null : new Date(cal.year, cal.month, day); // set new value - if same then disable

        this.write(cal);

        // ok - in the special case that it's all selects and there's always a date no matter what (at least as far as the form is concerned)
        // we can't let the calendar undo a date selection - it's just not possible!!
        if (!cal.val) { cal.val = this.read(cal); }

        if (cal.val) {
            this.check(cal); // checks other cals
            this.toggle(cal); // hide cal
        }
        else { // remove active class and replace with valid
            td.addClass(this.classes.valid);
            td.removeClass(this.classes.active);
        }
    },


    // display: create calendar element
    // @param cal (obj)

    display: function(cal) {
        // 1. header and navigation
        this.calendar.empty(); // init div

        this.calendar.className = this.classes.calendar + ' ' + this.options.months[cal.month].toLowerCase();

        var div = new Element('div').inject(this.calendar); // a wrapper div to help correct browser css problems with the caption element

        var table = new Element('table').inject(div).adopt(this.caption(cal));

        // 2. day names
        var thead = new Element('thead').inject(table);

        var tr = new Element('tr').inject(thead);

        for (var i = 0; i <= 6; i++) {
            var th = this.options.days[(i + this.options.offset) % 7];

            tr.adopt(new Element('th', { 'title': th }).appendText(th.substr(0, 1)));
        }

        // 3. day numbers
        var tbody = new Element('tbody').inject(table);
        var tr = new Element('tr').inject(tbody);

        var d = new Date(cal.year, cal.month, 1);
        var offset = ((d.getDay() - this.options.offset) + 7) % 7; // day of the week (offset)
        var last = new Date(cal.year, cal.month + 1, 0).getDate(); // last day of this month
        var prev = new Date(cal.year, cal.month, 0).getDate(); // last day of previous month
        var active = this.value(cal); // active date (if set and within curr month)
        var valid = cal.days; // valid days for curr month
        var inactive = []; // active dates set by other calendars
        var hilited = [];
        this.calendars.each(function(kal, i) {
            if (kal != cal && kal.val) {
                if (cal.year == kal.val.getFullYear() && cal.month == kal.val.getMonth()) { inactive.push(kal.val.getDate()); }

                if (cal.val) {
                    for (var day = 1; day <= last; day++) {
                        d.setDate(day);

                        if ((i < cal.id && d > kal.val && d < cal.val) || (i > cal.id && d > cal.val && d < kal.val)) {
                            if (!hilited.contains(day)) { hilited.push(day); }
                        }
                    }
                }
            }
        }, this);
        var d = new Date();
        var today = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime(); // today obv

        for (var i = 1; i < 43; i++) { // 1 to 42 (6 x 7 or 6 weeks)
            if ((i - 1) % 7 == 0) { tr = new Element('tr').inject(tbody); } // each week is it's own table row

            var td = new Element('td').inject(tr);

            var day = i - offset;
            var date = new Date(cal.year, cal.month, day);

            var cls = '';

            if (day === active) { cls = this.classes.active; } // active
            else if (inactive.contains(day)) { cls = this.classes.inactive; } // inactive
            else if (valid.contains(day)) { cls = this.classes.valid; } // valid
            else if (day >= 1 && day <= last) { cls = this.classes.invalid; } // invalid

            if (date.getTime() == today) { cls = cls + ' ' + this.classes.today; } // adds class for today

            if (hilited.contains(day)) { cls = cls + ' ' + this.classes.hilite; } // adds class if hilited

            td.addClass(cls);

            if (valid.contains(day)) { // if it's a valid - clickable - day we add interaction
                td.setProperty('title', this.format(date, 'D M jS Y'));

                td.addEvents({
                    'click': function(td, day, cal) {
                        this.clicked(td, day, cal);
                    }.pass([td, day, cal], this),
                    'mouseover': function(td, cls) {
                        td.addClass(cls);
                    }.pass([td, this.classes.hover]),
                    'mouseout': function(td, cls) {
                        td.removeClass(cls);
                    }.pass([td, this.classes.hover])
                });
            }

            // pad calendar with last days of prev month and first days of next month
            if (day < 1) { day = prev + day; }
            else if (day > last) { day = day - last; }

            td.appendText(day);
        }
    },


    // element: helper function
    // @param el (string) element id
    // @param f (string) format string
    // @param cal (obj)

    element: function(el, f, cal) {
        if (
            (this.mootools_version == '1.3+' && typeOf(f) == 'object') ||
            (this.mootools_version == '1.2' && $type(f) == 'object') 
        ) { // in the case of multiple inputs per calendar
            for (var i in f) {
                if (!this.element(i, f[i], cal)) { return false; }
            }

            return true;
        }

        el = $(el);

        if (!el) { return false; }

        el.format = f;

        if (el.get('tag') == 'select') { // select elements allow the user to manually set the date via select option
            el.addEvent('change', function(cal) { this.changed(cal); }.pass(cal, this));
        }
        else { // input (type text) elements restrict the user to only setting the date via the calendar
            //el.readOnly = true;
            //el.addEvent('focus', function(cal) { this.toggle(cal); }.pass(cal, this));
        }

        cal.els.push(el);

        return true;
    },


    // format: formats a date object according to passed in instructions
    // @param date (obj)
    // @param f (string) any combination of punctuation / separators and d, j, D, l, S, m, n, F, M, y, Y
    // @returns string

    format: function(date, format) {
        var str = '';

        if (date) {
            var j = date.getDate(); // 1 - 31
      var w = date.getDay(); // 0 - 6
            var l = this.options.days[w]; // Sunday - Saturday
            var n = date.getMonth() + 1; // 1 - 12
            var f = this.options.months[n - 1]; // January - December
            var y = date.getFullYear() + ''; // 19xx - 20xx

            for (var i = 0, len = format.length; i < len; i++) {
                var cha = format.charAt(i); // format char

                switch(cha) {
                    // year cases
                    case 'y': // xx - xx
                        y = y.substr(2);
                    case 'Y': // 19xx - 20xx
                        str += y;
                        break;

                    // month cases
                    case 'm': // 01 - 12
                        if (n < 10) { n = '0' + n; }
                    case 'n': // 1 - 12
                        str += n;
                        break;

                    case 'M': // Jan - Dec
                        f = f.substr(0, 3);
                    case 'F': // January - December
                        str += f;
                        break;

                    // day cases
                    case 'd': // 01 - 31
                        if (j < 10) { j = '0' + j; }
                    case 'j': // 1 - 31
                        str += j;
                        break;

                    case 'D': // Sun - Sat
                        l = l.substr(0, 3);
                    case 'l': // Sunday - Saturday
                        str += l;
                        break;

                    case 'N': // 1 - 7
                        w += 1;
                    case 'w': // 0 - 6
                        str += w;
                        break;

                    case 'S': // st, nd, rd or th (works well with j)
                        if (j % 10 == 1 && j != '11') { str += 'st'; }
                        else if (j % 10 == 2 && j != '12') { str += 'nd'; }
                        else if (j % 10 == 3 && j != '13') { str += 'rd'; }
                        else { str += 'th'; }
                        break;

                    default:
                        str += cha;
                }
            }
        }

      return str; //  return format with values replaced
    },


    // navigate: calendar navigation
    // @param cal (obj)
    // @param type (str) m or y for month or year
    // @param n (int) + or - for next or prev

    navigate: function(cal, type, n) {
        switch (type) {
            case 'm': // month
                    if (
                        (this.mootools_version == '1.3+' && typeOf(cal.months) == 'array') ||
                        (this.mootools_version == '1.2' && $type(cal.months) == 'array')
                    ) {
                        var i = cal.months.indexOf(cal.month) + n; // index of current month

                        if (i < 0 || i == cal.months.length) { // out of range
                            if (this.options.navigation == 1) { // if type 1 nav we'll need to increment the year
                                this.navigate(cal, 'y', n);
                            }

                            i = (i < 0) ? cal.months.length - 1 : 0;
                        }

                        cal.month = cal.months[i];
                    }
                    else {
                        var i = cal.month + n;

                        if (i < 0 || i == 12) {
                            if (this.options.navigation == 1) {
                                this.navigate(cal, 'y', n);
                            }

                            i = (i < 0) ? 11 : 0;
                        }

                        cal.month = i;
                    }
                    break;

                case 'y': // year
                    if (
                        (this.mootools_version == '1.3+' && typeOf(cal.years) == 'array') ||
                        (this.mootools_version == '1.2' && $type(cal.years) == 'array')
                    ) {
                        var i = cal.years.indexOf(cal.year) + n;

                        cal.year = cal.years[i];
                    }
                    else {
                        cal.year += n;
                    }
                    break;
        }

        if (this.mootools_version == '1.2') {
            $extend(cal, this.values(cal));
        } else {
            Object.append(cal, this.values(cal));
        }

        if (
            (this.mootools_version == '1.3+' && typeOf(cal.months) == 'array') ||
            (this.mootools_version == '1.2' && $(cal.months) == 'array')
        ) { // if the calendar has a months select
            var i = cal.months.indexOf(cal.month); // and make sure the curr months exists for the new year

            if (i < 0) { cal.month = cal.months[0]; } // otherwise we'll reset the month
        }


        this.display(cal);
    },


    // read: compiles cal value based on array of inputs passed in
    // @param cal (obj)
    // @returns date (obj) or (null)

    read: function(cal) {
        var arr = [null, null, null];

        cal.els.each(function(el) {
            // returns an array which may contain empty values
            var values = this.unformat(el.value, el.format);

            values.each(function(val, i) {
                if (
                    (this.mootools_version == '1.3+' && typeOf(val) == 'number') ||
                    (this.mootools_version == '1.2' && $type(val) == 'number')
                ) { arr[i] = val; }
            });
        }, this);

        // we can update the cals month and year values
        if (
            (this.mootools_version == '1.3+' && typeOf(arr[0]) == 'number') ||
            (this.mootools_version == '1.2' && $type(arr[0]) == 'number')
        ) { cal.year = arr[0]; }
        if (
            (this.mootools_version == '1.3+' && typeOf(arr[1]) == 'number') ||
            (this.mootools_version == '1.2' && $type(arr[1]) == 'number')
        ) { cal.month = arr[1]; }

        var val = null;

        if (arr.every(function(i) {
            return (
                (this.mootools_version == '1.3+' && typeOf(i) == 'number') ||
                (this.mootools_version == '1.2' && $type(i) == 'number')
            );
        })) { // if valid date
            var last = new Date(arr[0], arr[1] + 1, 0).getDate(); // last day of month

            if (arr[2] > last) { arr[2] = last; } // make sure we stay within the month (ex in case default day of select is 31 and month is feb)

            val = new Date(arr[0], arr[1], arr[2]);
        }

        return (cal.val == val) ? null : val; // if new date matches old return null (same date clicked twice = disable)
    },


    // rebuild: rebuilds days + months selects
    // @param cal (obj)

    rebuild: function(cal) {
        cal.els.each(function(el) {
            /*
            if (el.get('tag') == 'select' && el.format.test('^(F|m|M|n)$')) { // special case for months-only select
                if (!cal.options) { cal.options = el.clone(); } // clone a copy of months select

                var val = (cal.val) ? cal.val.getMonth() : el.value.toInt();

                el.empty(); // initialize select

                cal.months.each(function(month) {
                    // create an option element
                    var option = new Element('option', {
                        'selected': (val == month),
                        'value': this.format(new Date(1, month, 1), el.format);
                    }).appendText(day).inject(el);
                }, this);
            }
            */

            if (el.get('tag') == 'select' && el.format.test('^(d|j)$')) { // special case for days-only select
                var d = this.value(cal);

                if (!d) { d = el.value.toInt(); } // if the calendar doesn't have a set value, try to use value from select

                el.empty(); // initialize select

                cal.days.each(function(day) {
                    // create an option element
                    var option = new Element('option', {
                        'selected': (d == day),
                        'value': ((el.format == 'd' && day < 10) ? '0' + day : day)
                    }).appendText(day).inject(el);
                }, this);
            }
        }, this);
    },


    // sort: helper function for numerical sorting

    sort: function(a, b) {
        return a - b;
    },


    // toggle: show / hide calendar
    // @param cal (obj)

    toggle: function(cal) {
        document.removeEvent('mousedown', this.fn); // always remove the current mousedown script first

        if (cal.visible) { // simply hide curr cal
            cal.visible = false;
            cal.button.removeClass(this.classes.active); // active

            this.fx.start('opacity', 1, 0);
        }
        else { // otherwise show (may have to hide others)
            // hide cal on out-of-bounds click
            this.fn = function(e, cal) {
                var e = new Event(e);

                var el = e.target;

                var stop = false;

                while (el != document.body && el.nodeType == 1) {
                    if (el == this.calendar) { stop = true; }
                    this.calendars.each(function(kal) {
                        if (kal.button == el || kal.els.contains(el)) { stop = true; }
                    });

                    if (stop) {
                        e.stop();
                        return false;
                    }
                    else { el = el.parentNode; }
                }

                this.toggle(cal);
            }.create({ 'arguments': cal, 'bind': this, 'event': true });

            document.addEvent('mousedown', this.fn);

            this.calendars.each(function(kal) {
                if (kal == cal) {
                    kal.visible = true;
                    kal.button.addClass(this.classes.active); // css c-icon-active
                }
                else {
                    kal.visible = false;
                    kal.button.removeClass(this.classes.active); // css c-icon-active
                }
            }, this);

            var size = window.getScrollSize();

            var coord = cal.button.getCoordinates();

            var x = coord.right + this.options.tweak.x;
            var y = coord.top + this.options.tweak.y;

            // make sure the calendar doesn't open off screen
            if (!this.calendar.coord) { this.calendar.coord = this.calendar.getCoordinates(); }

            if (x + this.calendar.coord.width > size.x) { x -= (x + this.calendar.coord.width - size.x); }
            if (y + this.calendar.coord.height > size.y) { y -= (y + this.calendar.coord.height - size.y); }

            this.calendar.setStyles({ left: x + 'px', top: y + 'px' });

            if (
                (this.mootools_version == '1.2' && (Browser.Engine.trident4 || (Browser.Engine.gecko && Browser.Platform.mac))) ||
                (this.mootools_version == '1.3+' && (Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac)))
            ) {
                this.iframe.setStyles({ height: this.calendar.coord.height + 'px', left: x + 'px', top: y + 'px', width: this.calendar.coord.width + 'px' });
            }

            this.display(cal);

            this.fx.start('opacity', 0, 1);
        }
    },


    // unformat: takes a value from an input and parses the d, m and y elements
    // @param val (string)
    // @param f (string) any combination of punctuation / separators and d, j, D, l, S, m, n, F, M, y, Y
    // @returns array

    unformat: function(val, f) {
        f = f.escapeRegExp();

        var re = {
            d: '([0-9]{2})',
            j: '([0-9]{1,2})',
            D: '(' + this.options.days.map(function(day) { return day.substr(0, 3); }).join('|') + ')',
            l: '(' + this.options.days.join('|') + ')',
            S: '(st|nd|rd|th)',
            F: '(' + this.options.months.join('|') + ')',
            m: '([0-9]{2})',
            M: '(' + this.options.months.map(function(month) { return month.substr(0, 3); }).join('|') + ')',
            n: '([0-9]{1,2})',
            Y: '([0-9]{4})',
            y: '([0-9]{2})'
        }

        var arr = []; // array of indexes

        var g = '';

        // convert our format string to regexp
        for (var i = 0; i < f.length; i++) {
            var c = f.charAt(i);

            if (re[c]) {
                arr.push(c);

                g += re[c];
            }
            else {
                g += c;
            }
        }

        // match against date
        var matches = val.match('^' + g + '$');

        var dates = new Array(3);

        if (matches) {
            matches = matches.slice(1); // remove first match which is the date

            arr.each(function(c, i) {
                i = matches[i];

                switch(c) {
                    // year cases
                    case 'y':
                        i = '19' + i; // 2 digit year assumes 19th century (same as JS)
                    case 'Y':
                        dates[0] = i.toInt();
                        break;

                    // month cases
                    case 'F':
                        i = i.substr(0, 3);
                    case 'M':
                        i = this.options.months.map(function(month) { return month.substr(0, 3); }).indexOf(i) + 1;
                    case 'm':
                    case 'n':
                        dates[1] = i.toInt() - 1;
                        break;

                    // day cases
                    case 'd':
                    case 'j':
                        dates[2] = i.toInt();
                        break;
                }
            }, this);
        }

        return dates;
    },


    // value: returns day value of calendar if set
    // @param cal (obj)
    // @returns day (int) or null

    value: function(cal) {
        var day = null;

        if (cal.val) {
            if (cal.year == cal.val.getFullYear() && cal.month == cal.val.getMonth()) { day = cal.val.getDate(); }
        }

        return day;
    },


    // values: returns the years, months (for curr year) and days (for curr month and year) for the calendar
    // @param cal (obj)
    // @returns obj

    values: function(cal) {
        var years, months, days;

        cal.els.each(function(el) {
            if (el.get('tag') == 'select') {
                if (el.format.test('(y|Y)')) { // search for a year select
                    years = [];

                    el.getChildren().each(function(option) { // get options
                        var values = this.unformat(option.value, el.format);

                        if (!years.contains(values[0])) { years.push(values[0]); } // add to years array
                    }, this);

                    years.sort(this.sort);
                }

                if (el.format.test('(F|m|M|n)')) { // search for a month select
                    months = []; // 0 - 11 should be

                    el.getChildren().each(function(option) { // get options
                        var values = this.unformat(option.value, el.format);

                        if (
                            (
                                (this.mootools_version == '1.3+' && typeOf(values[0]) == 'number') ||
                                (this.mootools_version == '1.2' && $type(values[0]) == 'number')
                            )
                            || values[0] == cal.year
                        ) { // if it's a year / month combo for curr year, or simply a month select
                            if (!months.contains(values[1])) { months.push(values[1]); } // add to months array
                        }
                    }, this);

                    months.sort(this.sort);
                }

                if (el.format.test('(d|j)') && !el.format.test('^(d|j)$')) { // search for a day select, but NOT a days only select
                    days = []; // 1 - 31

                    el.getChildren().each(function(option) { // get options
                        var values = this.unformat(option.value, el.format);

                        // in the special case of days we dont want the value if its a days only select
                        // otherwise that will screw up the options rebuilding
                        // we will take the values if they are exact dates though
                        if (values[0] == cal.year && values[1] == cal.month) {
                            if (!days.contains(values[2])) { days.push(values[2]); } // add to days array
                        }
                    }, this);
                }
            }
        }, this);

        // we start with what would be the first and last days were there no restrictions
        var first = 1;
        var last = new Date(cal.year, cal.month + 1, 0).getDate(); // last day of the month

        // if we're in an out of bounds year
        if (cal.year == cal.start.getFullYear()) {
            // in the special case of improved navigation but no months array, we'll need to construct one
            if (months == null && this.options.navigation == 2) {
                months = [];

                for (var i = 0; i < 12; i ++) {
                    if (i >= cal.start.getMonth()) { months.push(i); }
                }
            }

            // if we're in an out of bounds month
            if (cal.month == cal.start.getMonth()) {
                first = cal.start.getDate(); // first day equals day of bound
            }
        }
        if (cal.year == cal.end.getFullYear()) {
            // in the special case of improved navigation but no months array, we'll need to construct one
            if (months == null && this.options.navigation == 2) {
                months = [];

                for (var i = 0; i < 12; i ++) {
                    if (i <= cal.end.getMonth()) { months.push(i); }
                }
            }

            if (cal.month == cal.end.getMonth()) {
                last = cal.end.getDate(); // last day equals day of bound
            }
        }

        // let's get our invalid days
        var blocked = this.blocked(cal);

        // finally we can prepare all the valid days in a neat little array
        if (
            (this.mootools_version == '1.3+' && typeOf(days) == 'array') ||
            (this.mootools_version == '1.2' && $type(days) == 'array')
        ) { // somewhere there was a days select
            days = days.filter(function(day) {
                if (day >= first && day <= last && !blocked.contains(day)) { return day; }
            });
        }
        else { // no days select we'll need to construct a valid days array
            days = [];

            for (var i = first; i <= last; i++) {
                if (!blocked.contains(i)) { days.push(i); }
            }
        }

        days.sort(this.sort); // sorting our days will give us first and last of month

        return { 'days': days, 'months': months, 'years': years };
    },


    // write: sets calendars value to form elements
    // @param cal (obj)

    write: function(cal) {
        this.rebuild(cal);     // in the case of options, we'll need to make sure we have the correct number of days available

        cal.els.each(function(el) {    // then we can set the value to the field
            el.value = this.format(cal.val, el.format);
            el.focus();
            el.blur();
        }, this);
    }
});

Calendar.implement(new Events, new Options);